/*
 * @Author: qiulei
 * @Date: 2022-02-16 11:26:41
 * @LastEditTime: 2022-02-16 20:07:06
 * @LastEditors: qiulei
 * @Description: 
 * @FilePath: /src2src/Main.backup.cpp
 */
#include "ConditionalOperatorRewrite.h"

static const char* SYSTEM_HEADERS[] =
{
    "/usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9",
    "/usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/x86_64-linux-gnu/c++/9",
    "/usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/x86_64-linux-gnu/c++/9",
    "/usr/lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/backward",
    "/usr/local/include",
    "/usr/local/llvm10ra/lib/clang/10.0.0/include",
    "/usr/include",
    "/usr/include/x86_64-linux-gnu"
};

static const char* RESOURCE_DIR = "/usr/local/llvm10ra/lib/clang/10.0.0";

int main(int argc, char *argv[]) {
  if (argc != 2) {
    cout << "Usage: rewritersample <filename>\n";
    return 1;
  }

  // CompilerInstance will hold the instance of the Clang compiler for us,
  // managing the various objects needed to run the compiler.
  CompilerInstance TheCompInst;
  TheCompInst.createDiagnostics();

  LangOptions &lo = TheCompInst.getLangOpts();
  lo.CXXExceptions = true ;
  // Activate C++11 parsing
  lo.Bool = true ;
  lo.WChar = true ;
  lo.CPlusPlus = true ;
  lo.CPlusPlus11 = true ;
  lo.CXXOperatorNames = true ;

  //Add -I options
  HeaderSearchOptions &ho = TheCompInst.getHeaderSearchOpts ();
  ho.UseBuiltinIncludes = true;
  ho.UseStandardSystemIncludes = true;
  ho.UseStandardCXXIncludes = true;
  ho.ResourceDir = RESOURCE_DIR;
  ho.AddPath( "/usr/local/share/verilator/include",
                  clang::frontend::Angled,
                  false,
                  false); 
  ho.AddPath( "/usr/local/share/verilator/include/vltstd",
                  clang::frontend::Angled,
                  false,
                  false); 
  for (const auto sytemHeader : SYSTEM_HEADERS){
    ho.AddPath(sytemHeader, frontend::System, false, false);
  }

  // Initialize target info with the default triple for our platform.
  auto TO = std::make_shared<TargetOptions>();
  TO->Triple = llvm::sys::getDefaultTargetTriple();
  TargetInfo *TI =
      TargetInfo::CreateTargetInfo(TheCompInst.getDiagnostics(), TO);
  TheCompInst.setTarget(TI);

  TheCompInst.createFileManager();
  FileManager &FileMgr = TheCompInst.getFileManager();
  TheCompInst.createSourceManager(FileMgr);
  SourceManager &SourceMgr = TheCompInst.getSourceManager();
  TheCompInst.createPreprocessor(TU_Module);
  TheCompInst.createASTContext();

  // A Rewriter helps us manage the code rewriting task.
  Rewriter TheRewriter;
  TheRewriter.setSourceMgr(SourceMgr, TheCompInst.getLangOpts());

  // Set the main file handled by the source manager to the input file.
  auto FileIn = FileMgr.getFileRef(argv[1]);
  if(!FileIn){
    cout << "ERROR: No such file!\n";
    return 1;
  }
  SourceMgr.setMainFileID(
      SourceMgr.createFileID(&(FileIn->getFileEntry()), SourceLocation(), SrcMgr::C_User));
  TheCompInst.getDiagnosticClient().BeginSourceFile(
      TheCompInst.getLangOpts(), &TheCompInst.getPreprocessor());

  // Create an AST consumer instance which is going to get called by
  // ParseAST.
  ConditionalOperatorConsumer TheConsumer(TheRewriter);

  // Parse the file to AST, registering our consumer as the AST consumer.
  ParseAST(TheCompInst.getPreprocessor(), &TheConsumer,
           TheCompInst.getASTContext());

  // At this point the rewriter's buffer should be full with the rewritten
  // file contents.
  const RewriteBuffer *RewriteBuf =
      TheRewriter.getRewriteBufferFor(SourceMgr.getMainFileID());
  llvm::outs() << std::string(RewriteBuf->begin(), RewriteBuf->end());

  return 0;
}